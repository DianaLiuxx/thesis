/*
 * Code generated by MIMOS tool.
 * Date: 2024/04/14 14:28:26
 * 
 * 
 *  * Inputs: .txt file which contains problem described in STRIPS language as fllowing format:
 * - Symbols
 * - Initial conditions
 * - Goal conditions
 * - Actions:
 *     - [Action Name]
 *     - Preconditions
 *     - Effects
 * 
 * 
 * Classes:
 * - GroundedCondition:
 * - Condition:

 * 
 * 
 */

import java.util.Random;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.ArrayList;
import java.util.*;
import java.util.Objects;
import java.util.Set;
import java.util.HashSet;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Sym_Planner {
    int aStarWeight = 1;
    String filePath = "D:\\lxx\\thesis\\cases\\lxx\\sym\\data\\input-problems\\FireExtinguisher.txt";
    // String filePath =
    // "D:\\lxx\\thesis\\cases\\lxx\\sym\\data\\input-problems\\Blocks.txt";

    Environment env;
    Set<GroundedCondition> startState = new HashSet<>();
    Set<GroundedCondition> goalState = new HashSet<>();
    Set<GroundedAction> allGroundedActions = new HashSet<>();
    int maxAddedLiterals = 0;

    Map<String, Boolean> visitedStates = new HashMap<>();
    Map<String, Integer> gVals = new HashMap<>();
    PriorityQueue<Node> heap = new PriorityQueue<>(Comparator.comparingDouble(n -> n.f));
    List<GroundedAction> finalActions = new ArrayList<>();

    String outfilePath = "D:\\lxx\\thesis\\cases\\lxx\\sym\\data\\outputs\\plan.txt";
    int bootTime = 1;

    /* Inputs: */

    /* Outputs: */

    public Sym_Planner() {
        env = new Environment(filePath);
        startState = env.getStartConds();
        goalState = env.getGoalConds();
        maxAddedLiterals = env.getMaxAddedLiterals();
        allGroundedActions = env.getAllGroundedActs();
        System.out.println(env.toString());
    }

    /* Node computation: */
    public boolean run() {

        if (bootTime == 1) {
            // A* algorithm
            Node startNode = new Node(startState, 0, getHeuristic(startState), null, null);
            heap.add(startNode);

            while (!heap.isEmpty()) {
                Node expNode = heap.poll();

                if (isVisited(expNode.state) && expNode.g >= getGVal(expNode.state)) {
                    continue;
                }

                makeVisited(expNode.state);

                if (isGoalState(expNode.state)) {
                    for (Node n = expNode; n.parent != null; n = n.parent) {
                        //System.out.println(n.parentAct.toString());
                        finalActions.add(n.parentAct);
                    }
                    break;
                }

                for (GroundedAction g_act : allGroundedActions) {
                    if (!canApplyAction(expNode.state, g_act)) {
                        continue;
                    }
                    Set<GroundedCondition> newState = applyAction(expNode.state, g_act);
                    int newCost = expNode.g + 1;
                    if (newCost < getGVal(newState)) {
                        updateGVal(newState, newCost);
                        heap.add(new Node(newState, newCost, getHeuristic(newState), expNode,
                                new GroundedAction(g_act.getName(), g_act.getArgValues())));
                    }
                }

            }

            bootTime = 0;
        }

        Collections.reverse(finalActions);

        // Print the final plan

        try (BufferedWriter pathFile = new BufferedWriter(new FileWriter(outfilePath))) {
            for (GroundedAction gac : finalActions) {
                pathFile.write(gac.toString());
                pathFile.newLine();
            }
        } catch (IOException e) {
            System.out.println("An error occurred while writing to the file: " + e.getMessage());
        }

        return true;
    }

    /* Setters (for inputs): */

    /* Getters (for outputs): */

    // auxiliary functions for A* algorithm
    public double getHeuristic(Set<GroundedCondition> s) {
        int diff = 0;
        for (GroundedCondition gCond : goalState) {
            if (!s.contains(gCond))
                diff++;

        }
        return (double) diff / maxAddedLiterals * aStarWeight;
    }

    public boolean isGoalState(Set<GroundedCondition> s) {
        for (GroundedCondition gCond : goalState) {
            if (!s.contains(gCond)) {
                return false;
            }
        }
        return true;
    }

    public String convertStateToString(Set<GroundedCondition> s) {
        StringBuilder temp = new StringBuilder();
        s.forEach(gc -> temp.append(gc.toString()));
        return temp.toString();
    }

    public boolean isVisited(Set<GroundedCondition> s) {
        String stateAsString = convertStateToString(s);
        return visitedStates.containsKey(stateAsString);
    }

    public void makeVisited(Set<GroundedCondition> s) {
        String key = convertStateToString(s);
        visitedStates.put(key, true);
    }

    public int getGVal(Set<GroundedCondition> s) {
        String key = convertStateToString(s);
        return gVals.getOrDefault(key, Integer.MAX_VALUE);
    }

    public void updateGVal(Set<GroundedCondition> s, int val) {
        String key = convertStateToString(s);
        gVals.put(key, val);
    }

    public boolean canApplyAction(Set<GroundedCondition> s, GroundedAction ga) {
        for (GroundedCondition precond : ga.getPreconditions()) {
            if (!s.contains(precond)) {
                return false;
            }
        }
        return true;
    }

    public Set<GroundedCondition> applyAction(Set<GroundedCondition> s, GroundedAction ga) {
        Set<GroundedCondition> newState = new HashSet<>(s);

        for (GroundedCondition effect : ga.getEffects()) {
            if (effect.getTruth()) {
                newState.add(effect);
            } else {
                GroundedCondition negatedEffect = effect.getNegated();
                // assert newState.contains(negatedEffect) : "Negated effect not found in the
                // state";
                newState.remove(negatedEffect);
            }
        }

        return newState;
    }

    // Node class for A* algorithm
    public class Node implements Comparable<Node> {
        Set<GroundedCondition> state = new HashSet<>();
        int g;
        double h;
        double f; // f = g + h * weight
        Node parent; // Parent node
        GroundedAction parentAct; // Action that led to this node

        public Node(Set<GroundedCondition> state, int g, double h, Node parent, GroundedAction parentAct) {
            this.state = state;
            this.g = g;
            this.h = h;
            this.f = g + h;
            this.parent = parent;
            this.parentAct = parentAct;
        }

        @Override
        public int compareTo(Node other) {
            return Double.compare(this.f, other.f); // lower f values have higher priority
        }
    }

    private class Environment {
        private Set<Condition> preconditions = new HashSet<>();
        private Set<Condition> effects = new HashSet<>();
        private Set<GroundedCondition> startConds = new HashSet<>();
        private Set<GroundedCondition> goalConds = new HashSet<>();
        private Set<Action> actions = new HashSet<>();
        private Set<String> symbols = new HashSet<>();

        public enum PARSER {
            Symbols, Initial, Goal, Actions, Action_Definition, Action_Precondition, Action_Effect
        }

        private PARSER parser = PARSER.Symbols;

        public Environment(String filePath) {
            String line;
            String actionName = "", actionArgs = "";

            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {

                Pattern symbolStateRegex = Pattern.compile("^symbols:", Pattern.CASE_INSENSITIVE);
                Pattern symbolRegex = Pattern.compile("([a-zA-Z0-9_, ]+)");
                Pattern initialConditionRegex = Pattern.compile("^initialconditions:(.*)", Pattern.CASE_INSENSITIVE);
                Pattern conditionRegex = Pattern.compile("(!?[A-Z][a-zA-Z_]*)\\s*\\(([^)]+)\\)");
                Pattern goalConditionRegex = Pattern.compile("^goalconditions:(.*)", Pattern.CASE_INSENSITIVE);
                Pattern actionRegex = Pattern.compile("^actions:", Pattern.CASE_INSENSITIVE);
                Pattern precondRegex = Pattern.compile("^preconditions:(.*)", Pattern.CASE_INSENSITIVE);
                Pattern effectRegex = Pattern.compile("^effects:(.*)", Pattern.CASE_INSENSITIVE);

                while ((line = reader.readLine()) != null) {
                    line = line.replaceAll("\\s+", "");
                    if (line.isEmpty())
                        continue;

                    switch (this.parser) {
                        case Symbols:
                            Matcher symbolMatcher = symbolStateRegex.matcher(line);
                            if (symbolMatcher.find()) {
                                line = line.substring(8);
                                Matcher iter = symbolRegex.matcher(line);
                                if (iter.find()) {
                                    addSymbols(parseSymbols(iter.group()));
                                    parser = PARSER.Initial;
                                } else {
                                    throw new RuntimeException("Symbols are not specified correctly");
                                }
                            }
                            // System.out.println("Symbols: " + symbols.toString());
                            break;

                        case Initial:
                            Matcher initialMatcher = initialConditionRegex.matcher(line);
                            if (initialMatcher.find()) {
                                line = line.substring(16);
                                Matcher iter = conditionRegex.matcher(line);
                                while (iter.find()) {
                                    String predicate = iter.group(1);
                                    String args = iter.group(2);

                                    if (predicate.startsWith("!")) {
                                        this.removeStartCond(
                                                new GroundedCondition(predicate.substring(1), parseSymbols(args)));
                                    } else {
                                        this.addStartCond(new GroundedCondition(predicate, parseSymbols(args)));
                                    }
                                    // System.out.println("Initial conditions: " + predicate + " " + args);
                                }
                                parser = PARSER.Goal;
                            } else {
                                throw new RuntimeException("Initial conditions not specified correctly");
                            }
                            break;

                        case Goal:
                            Matcher goalMatcher = goalConditionRegex.matcher(line);
                            if (goalMatcher.find()) {
                                line = line.substring(13);
                                Matcher iter = conditionRegex.matcher(line);
                                while (iter.find()) {
                                    String predicate = iter.group(1);
                                    String args = iter.group(2);

                                    if (predicate.startsWith("!")) {
                                        this.removeGoalCond(
                                                new GroundedCondition(predicate.substring(1), parseSymbols(args)));
                                    } else {
                                        this.addGoalCond(new GroundedCondition(predicate, parseSymbols(args)));
                                    }
                                    // System.out.println("Goal conditions: " + predicate + " " + args);
                                }
                                parser = PARSER.Actions;
                            } else {
                                throw new RuntimeException("Goal conditions not specified correctly");
                            }
                            break;

                        case Actions:
                            Matcher actionMatcher = actionRegex.matcher(line);
                            if (actionMatcher.find()) {
                                parser = PARSER.Action_Definition;
                            } else {
                                throw new RuntimeException("Actions not specified correctly");
                            }
                            break;

                        case Action_Definition:
                            if (conditionRegex.matcher(line).matches()) {
                                Matcher iter = conditionRegex.matcher(line);
                                iter.find();
                                actionName = iter.group(1);
                                actionArgs = iter.group(2);
                                parser = PARSER.Action_Precondition;
                            } else {
                                throw new RuntimeException("Action not specified correctly");
                            }
                            // System.out.println("Action: " + actionName + " " + actionArgs);
                            break;

                        case Action_Precondition:
                            if (precondRegex.matcher(line).matches()) {
                                Matcher iter = conditionRegex.matcher(line);
                                while (iter.find()) {
                                    String predicate = iter.group(1);
                                    String args = iter.group(2);
                                    boolean truth = !predicate.startsWith("!");
                                    if (!truth) {
                                        predicate = predicate.substring(1);
                                    }
                                    Condition precond = new Condition(predicate, parseSymbols(args), truth);
                                    preconditions.add(precond);
                                    // System.out.println("Precondition: " + predicate + " " + args);
                                }
                                parser = PARSER.Action_Effect;
                            } else {
                                throw new RuntimeException("Precondition not specified correctly");
                            }
                            break;

                        case Action_Effect:
                            if (effectRegex.matcher(line).matches()) {
                                Matcher iter = conditionRegex.matcher(line);
                                while (iter.find()) {
                                    String predicate = iter.group(1);
                                    String args = iter.group(2);
                                    boolean truth = !predicate.startsWith("!");
                                    if (!truth) {
                                        predicate = predicate.substring(1);
                                    }
                                    Condition effect = new Condition(predicate, parseSymbols(args), truth);
                                    effects.add(effect);
                                    // System.out.println("Effect: " + predicate + " " + args);
                                }
                                addAction(new Action(actionName, parseSymbols(actionArgs), preconditions, effects));
                                preconditions.clear();
                                effects.clear();
                                parser = PARSER.Action_Definition;
                            } else {
                                throw new RuntimeException("Effects not specified correctly");
                            }
                            break;

                        default:
                            break;
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        private List<String> parseSymbols(String symbolsStr) {
            List<String> symbols = new ArrayList<>();
            String[] parts = symbolsStr.split(",");
            for (String part : parts) {
                symbols.add(part.trim());
            }
            return symbols;
        }

        public Set<GroundedCondition> getStartConds() {
            return startConds;
        }

        public Set<GroundedCondition> getGoalConds() {
            return goalConds;
        }

        public void getPerms(List<List<String>> combs, List<String> prefix, int length) {
            if (length == 0) {
                combs.add(new ArrayList<>(prefix));
                return;
            }

            for (String sym : symbols) {
                List<String> newPrefix = new ArrayList<>(prefix);
                newPrefix.add(sym);
                getPerms(combs, newPrefix, length - 1);
            }
        }

        public void addStartCond(GroundedCondition gc) {
            startConds.add(gc);
        }

        public void removeStartCond(GroundedCondition gc) {
            startConds.remove(gc);
        }

        public void addGoalCond(GroundedCondition gc) {
            goalConds.add(gc);
        }

        public void removeGoalCond(GroundedCondition gc) {
            goalConds.remove(gc);
        }

        public void addSymbol(String symbol) {
            symbols.add(symbol);
        }

        public void addSymbols(List<String> newSymbols) {
            symbols.addAll(newSymbols);
        }

        public Set<String> getSymbols() {
            return new HashSet<>(symbols);
        }

        public void addAction(Action action) {
            actions.add(action);
        }

        public List<List<String>> getAllSymCombs(int length) {
            if (length > symbols.size()) {
                throw new IllegalArgumentException("Length greater than the number of symbols.");
            }
            List<List<String>> combs = new ArrayList<>();
            getPerms(combs, new ArrayList<>(), length);
            return combs;
        }

        public Action getAction(String name) {
            for (Action a : actions) {
                if (a.getName().equals(name)) {
                    return a;
                }
            }
            throw new RuntimeException("Action " + name + " not found!");
        }

        public Set<GroundedAction> getAllGroundedActs() {
            Set<GroundedAction> allGroundedActs = new HashSet<>();

            for (Action act : actions) {
                String grActName = act.getName();
                List<String> actArgs = act.getArgs();
                List<List<String>> symPerms = getAllSymCombs(actArgs.size());

                for (List<String> perm : symPerms) {
                    Map<String, String> dict = new HashMap<>();
                    for (int i = 0; i < actArgs.size(); i++) {
                        dict.put(actArgs.get(i), perm.get(i));
                    }

                    List<String> grActArgsVals = new ArrayList<>();
                    for (String arg : actArgs) {
                        grActArgsVals.add(dict.get(arg));
                    }

                    Set<GroundedCondition> grActPreconds = new HashSet<>();
                    for (Condition cond : act.getPreconditions()) {
                        grActPreconds.add(cond.groundTheCondition(dict));
                    }

                    Set<GroundedCondition> grActAllRawEffects = new HashSet<>();
                    for (Condition cond : act.getEffects()) {
                        grActAllRawEffects.add(cond.groundTheCondition(dict));
                    }

                    Set<GroundedCondition> grActEffectiveEffects = new HashSet<>();
                    for (GroundedCondition effect1 : grActAllRawEffects) {
                        boolean effective = true;
                        for (GroundedCondition effect2 : grActAllRawEffects) {
                            if (effect1.equals(effect2.getNegated())) {
                                effective = false;
                                break;
                            }
                        }
                        if (effective) {
                            grActEffectiveEffects.add(effect1);
                        }
                    }

                    if (!grActEffectiveEffects.isEmpty()) {
                        allGroundedActs.add(
                                new GroundedAction(grActName, grActArgsVals, grActPreconds, grActEffectiveEffects));
                    }
                }
            }

            return allGroundedActs;
        }

        public int getMaxAddedLiterals() {
            int max = -1;
            for (Action ac : actions) {
                int count = ac.getAddedLiterals();
                if (count > max) {
                    max = count;
                }
            }
            return max;
        }

        @Override
        public String toString() {
            StringBuilder os = new StringBuilder();
            os.append("***** Environment *****\n\n");
            os.append("Symbols: ");
            for (String s : symbols)
                os.append(s).append(",");
            os.deleteCharAt(os.length() - 1); // Remove the last comma

            os.append("\nInitial conditions: ");
            for (GroundedCondition s : startConds)
                os.append(s.toString());
            os.append("\nGoal conditions: ");
            for (GroundedCondition g : goalConds)
                os.append(g.toString());
            os.append("\nActions:\n");
            for (Action g : actions)
                os.append(g.toString()).append("\n");
            os.append("***** Environment Created! *****\n");
            return os.toString();
        }

    }

    public class GroundedCondition {
        private String predicate;
        private List<String> argValues;
        private boolean truth;

        public GroundedCondition(String predicate, List<String> argValues, boolean truth) {
            this.predicate = predicate;
            this.truth = truth;
            this.argValues = new ArrayList<>(argValues);
        }

        public GroundedCondition(String predicate, List<String> argValues) {
            this(predicate, argValues, true);
        }

        public GroundedCondition getNegated() {
            return new GroundedCondition(this.predicate, this.argValues, !this.truth);
        }

        @Override
        public String toString() {
            StringBuilder temp = new StringBuilder();
            if (!this.truth)
                temp.append("!");
            temp.append(this.predicate);
            temp.append("(");
            for (String l : this.argValues) {
                temp.append(l).append(",");
            }
            if (!this.argValues.isEmpty()) {
                temp.deleteCharAt(temp.length() - 1); // Remove the last comma
            }
            temp.append(")");
            return temp.toString();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            GroundedCondition that = (GroundedCondition) o;
            return truth == that.truth &&
                    Objects.equals(predicate, that.predicate) &&
                    Objects.equals(argValues, that.argValues);
        }

        @Override
        public int hashCode() {
            return Objects.hash(predicate, argValues, truth);
        }

        public String getPredicate() {
            return predicate;
        }

        public List<String> getArgValues() {
            return new ArrayList<>(argValues);
        }

        public boolean getTruth() {
            return truth;
        }
    }

    public class Condition {
        private String predicate;
        private List<String> args;
        private boolean truth;

        public Condition(String predicate, List<String> args, boolean truth) {
            this.predicate = predicate;
            this.truth = truth;
            this.args = new ArrayList<>(args);
        }

        // Get all possible argument values
        public GroundedCondition groundTheCondition(Map<String, String> dict) {
            List<String> argVals = new ArrayList<>();
            for (String arg : this.args) {
                if (!dict.containsKey(arg)) {
                    argVals.add(arg);
                } else {
                    argVals.add(dict.get(arg));
                }
            }
            return new GroundedCondition(this.predicate, argVals, this.truth);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            Condition condition = (Condition) o;
            return truth == condition.truth &&
                    Objects.equals(predicate, condition.predicate) &&
                    Objects.equals(args, condition.args);
        }

        @Override
        public int hashCode() {
            return Objects.hash(predicate, args, truth);
        }

        @Override
        public String toString() {
            StringBuilder temp = new StringBuilder();
            if (!this.truth)
                temp.append("!");
            temp.append(this.predicate).append("(");
            for (String l : this.args) {
                temp.append(l).append(",");
            }
            if (!this.args.isEmpty())
                temp.deleteCharAt(temp.length() - 1);
            temp.append(")");
            return temp.toString();
        }

        public String getPredicate() {
            return predicate;
        }

        public List<String> getArgs() {
            return new ArrayList<>(args);
        }

        public boolean getTruth() {
            return truth;
        }
    }

    public class Action {
        private String name;
        private List<String> args;
        private Set<Condition> preconditions;
        private Set<Condition> effects;

        public Action(String name, List<String> args, Set<Condition> preconditions, Set<Condition> effects) {
            this.name = name;
            this.args = new ArrayList<>(args);
            this.preconditions = new HashSet<>(preconditions);
            this.effects = new HashSet<>(effects);
        }

        public int getAddedLiterals() {
            int num = 0;
            for (Condition cond : effects) {
                if (cond.getTruth())
                    num++;
            }
            return num;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            Action action = (Action) o;
            return name.equals(action.name) && args.equals(action.args);
        }

        @Override
        public int hashCode() {
            return Objects.hash(name, args);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder(name);
            sb.append("(");
            args.forEach(arg -> sb.append(arg).append(","));
            if (!args.isEmpty()) {
                sb.setLength(sb.length() - 1); // Remove the last comma
            }
            sb.append(")");
            return sb.toString();
        }

        public String getName() {
            return name;
        }

        public List<String> getArgs() {
            return args;
        }

        public Set<Condition> getPreconditions() {
            return preconditions;
        }

        public Set<Condition> getEffects() {
            return effects;
        }
    }

    public class GroundedAction {
        private String name;
        private List<String> argValues;
        private Set<GroundedCondition> preconditions;
        private Set<GroundedCondition> effects;

        public GroundedAction(String name, List<String> argValues) {
            this.name = name;
            this.argValues = new ArrayList<>(argValues);
            this.preconditions = new HashSet<>();
            this.effects = new HashSet<>();
        }

        public GroundedAction(String name, List<String> argValues, Set<GroundedCondition> preconditions,
                Set<GroundedCondition> effects) {
            this.name = name;
            this.argValues = new ArrayList<>(argValues);
            this.preconditions = new HashSet<>(preconditions);
            this.effects = new HashSet<>(effects);
        }

        public void printAction() {
            System.out.println("GroundedAction:");
            System.out.println("name: " + name);
            System.out.print("argValues: ");
            argValues.forEach(arg -> System.out.print(arg + " "));
            System.out.println("\npreconditions: ");
            preconditions.forEach(p -> System.out.print(p + " "));
            System.out.println("\neffects: ");
            effects.forEach(e -> System.out.print(e + " "));
            System.out.println();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            GroundedAction that = (GroundedAction) o;
            return Objects.equals(name, that.name) &&
                    Objects.equals(argValues, that.argValues);
        }

        @Override
        public int hashCode() {
            return Objects.hash(name, argValues);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder(name);
            sb.append("(");
            argValues.forEach(arg -> sb.append(arg).append(","));
            if (!argValues.isEmpty()) {
                sb.setLength(sb.length() - 1); // Remove the last comma
            }
            sb.append(")");
            return sb.toString();
        }

        public String getName() {
            return name;
        }

        public List<String> getArgValues() {
            return argValues;
        }

        public Set<GroundedCondition> getPreconditions() {
            return preconditions;
        }

        public Set<GroundedCondition> getEffects() {
            return effects;
        }
    }

}