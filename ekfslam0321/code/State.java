/*
 * Code generated by MIMOS tool.
 * Date: 2024/03/22 10:53:14
 * 
 * Provide the state of the robot and landmarksï¼ˆmean and covariance matrix P).
 * At the first time, initialize these values. After that, choose the update values.
 *
 *
 * 
 */

import java.util.Random;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.ArrayList;
import java.util.*;

public class State {
    /* Inputs: */
    double[] input1; // Updated mean, 3+2*6=15 values
    double[] input2; // Updated covariance matrix, 15*15=225 values

    /* Outputs: */
    double[] output1; // Mean of the state vector
    double[] output2; // Covariance matrix P of the state vector

    static boolean selectUpdated = false; // Select the initial values
    String filePath = "D:\\lxx\\thesis\\cases\\lxx\\ekfslam0321\\data\\outputs\\X.txt";
    int count = 0;

    // Uncertainty parameters
    double sigX2 = 0.25 * 0.25;
    double sigY2 = 0.1 * 0.1;
    double sigAlpha2 = 0.1 * 0.1; // Rotation
    double sigBeta2 = 0.01 * 0.01; // Bearing angle
    double sigR2 = 0.08 * 0.08; // Range

    ExtKalmanFilter ekf;

    public State() {
        // Initial landmarks with the first observation
        double[] initialMeasurement = { 1.1072, 6.7060, 1.3257, 12.3812, 0.8520, 10.6270, 1.1071, 15.6513, 0.4995,
                12.5422, 0.8289, 16.2816 };
        ekf = new ExtKalmanFilter(sigX2, sigY2, sigAlpha2, sigBeta2, sigR2, initialMeasurement);
    }

    /* Node computation: */
    public boolean run() {
        System.out.println("\nState.java: run() is called. " + "Count: " + count++);

        if (!selectUpdated) {
            output1 = ekf.X;
            System.out.println("[State output]: Initial values.\n");

            // ekf.numEntries * ekf.numEntries = 225 values
            output2 = new double[ekf.numEntries * ekf.numEntries];
            for (int i = 0; i < ekf.numEntries; i++) {
                for (int j = 0; j < ekf.numEntries; j++) {
                    output2[i * ekf.numEntries + j] = ekf.P[i][j];
                }
            }
            selectUpdated = true;

            try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, StandardCharsets.UTF_8, true))) {    
                for (double value : output1) {
                    // Only keep 4 decimal places
                    writer.print(String.format("%.4f ", value));
                }
                writer.print("\n");
            } catch (IOException e) {
                e.printStackTrace();
            }

        } else if ((input1 != null && input1.length != 0) && (input2 != null && input2.length != 0) && selectUpdated) {
            output1 = input1;
            output2 = input2;
            System.out.println("[State output]: Updated values\n");

        } else {
            output1 = null;
            output2 = null;
            System.out.println("[State output]: No output\n");
        }

        return true;
    }

    /* Help methods: */
    public static void matrixTranspose(double[][] A, double[][] B, int row, int col) {
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                B[j][i] = A[i][j];
            }
        }
    }

    public static void matrixMultiplication(double[][] A, double[][] B, double[][] res, int rowA, int rowB, int colB) {
        for (int i = 0; i < rowA; i++) {
            for (int j = 0; j < colB; j++) {
                res[i][j] = 0;
                for (int k = 0; k < rowB; k++) {
                    res[i][j] += A[i][k] * B[k][j];
                }
            }
        }
    }

    public static void matrixAddition(double[][] A, double[][] B, double[][] res, int rows, int cols) {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[i][j] = A[i][j] + B[i][j];
            }
        }
    }

    /* Setters (for inputs): */
    public void set_input1(double[] i) {
        input1 = i;
    }

    public void set_input2(double[] i) {
        input2 = i;
    }

    /* Getters (for outputs): */
    public double[] get_output1() {
        return output1;
    }

    public double[] get_output2() {
        return output2;
    }

    public class ExtKalmanFilter {
        private double[] X; // State vector
        private double[][] P; // Covariance matrix
        private double[][] controlCov;
        private double[][] measurementCov;

        private int numLandmarks;
        private final int STATE_ENTRIES = 3; // X, Y, Theta
        private final int NUM_MEAS_TYPE = 2; // Range and bearing angle
        private int numEntries; // Total entries representing robot and landmarks

        public ExtKalmanFilter(double sigX2, double sigY2, double sigAlpha2, double sigBeta2, double sigR2,
                double[] initialMeasurement) {
            numLandmarks = initialMeasurement.length / 2;

            controlCov = new double[STATE_ENTRIES][STATE_ENTRIES];
            controlCov[0][0] = sigX2;
            controlCov[1][1] = sigY2;
            controlCov[2][2] = sigAlpha2;

            measurementCov = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
            measurementCov[0][0] = sigBeta2;
            measurementCov[1][1] = sigR2;

            // Initial position and uncertainty
            double rX = 0, rY = 0, rTheta = 0;
            double[] pos = { rX, rY, rTheta };

            double[][] posCov = new double[STATE_ENTRIES][STATE_ENTRIES];
            posCov[0][0] = 0.02 * 0.02;
            posCov[1][1] = 0.02 * 0.02;
            posCov[2][2] = 0.1 * 0.1;

            // Landmarks and their covariance
            double[] landmarks = new double[2 * numLandmarks];
            double[][] landmarksCov = new double[2 * numLandmarks][2 * numLandmarks];

            for (int l = 0; l < numLandmarks; l++) {
                double lBeta = initialMeasurement[2 * l];
                double lRange = initialMeasurement[2 * l + 1];

                double lX = rX + lRange * Math.cos(rTheta + lBeta);
                double lY = rY + lRange * Math.sin(rTheta + lBeta);

                landmarks[2 * l] = lX;
                landmarks[2 * l + 1] = lY;

                double[][] jacobian = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
                jacobian[0][0] = -lRange * Math.sin(rTheta + lBeta);
                jacobian[0][1] = Math.cos(rTheta + lBeta);
                jacobian[1][0] = lRange * Math.cos(rTheta + lBeta);
                jacobian[1][1] = Math.sin(rTheta + lBeta);

                double[][] jacobianT = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
                matrixTranspose(jacobian, jacobianT, NUM_MEAS_TYPE, NUM_MEAS_TYPE);

                double[][] temp = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
                matrixMultiplication(jacobian, measurementCov, temp, NUM_MEAS_TYPE, NUM_MEAS_TYPE,
                        NUM_MEAS_TYPE);

                double[][] lCov = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
                matrixMultiplication(temp, jacobianT, lCov, NUM_MEAS_TYPE, NUM_MEAS_TYPE, NUM_MEAS_TYPE);

                landmarksCov[2 * l][2 * l] = lCov[0][0];
                landmarksCov[2 * l][2 * l + 1] = lCov[0][1];
                landmarksCov[2 * l + 1][2 * l] = lCov[1][0];
                landmarksCov[2 * l + 1][2 * l + 1] = lCov[1][1];
            }

            // State vector X: pos and landmarks
            // State vector X and covariance matrix P initialization
            numEntries = STATE_ENTRIES + NUM_MEAS_TYPE * numLandmarks;
            X = new double[numEntries];
            X[0] = pos[0];
            X[1] = pos[1];
            X[2] = pos[2];
            for (int i = 0; i < numLandmarks; i++) {
                X[STATE_ENTRIES + NUM_MEAS_TYPE * i] = landmarks[NUM_MEAS_TYPE * i];
                X[STATE_ENTRIES + NUM_MEAS_TYPE * i + 1] = landmarks[NUM_MEAS_TYPE * i + 1];
            }

            P = new double[numEntries][numEntries];
            for (int i = 0; i < STATE_ENTRIES; i++) {
                for (int j = 0; j < STATE_ENTRIES; j++) {
                    P[i][j] = posCov[i][j];
                }
            }
            for (int i = 0; i < 2 * numLandmarks; i++) {
                for (int j = 0; j < 2 * numLandmarks; j++) {
                    int xIdx = STATE_ENTRIES + i;
                    int yIdx = STATE_ENTRIES + j;
                    P[xIdx][yIdx] = landmarksCov[i][j];
                }
            }
        }
    }
}
