/*
 * Code generated by MIMOS tool.
 * Date: 2024/03/22 13:54:27
 */

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class Update {
    /* Inputs: */
    double[] input1; // P
    double[] input2; // X
    double[] input3; // measure from log

    /* Outputs: */
    double[] output1; // Updated X
    double[] output2; // Updated P
    String filePath = "D:\\lxx\\thesis\\cases\\lxx\\ekfslam0321\\data\\outputs\\X.txt";

    double sigBeta2 = 0.01 * 0.01; // Bearing angle
    double sigR2 = 0.08 * 0.08; // Rang
    int numLandmarks = 6; // six landmarks
    final int STATE_ENTRIES = 3; // X, Y, Theta
    final int NUM_MEAS_TYPE = 2; // Range and bearing angle
    int numEntries;

    static double[][] eye; // Identity matrix
    double[] X; // State vector
    double[][] P; // Covariance matrix
    double[][] measurementCov;

    public Update() {
        measurementCov = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
        measurementCov[0][0] = sigBeta2;
        measurementCov[1][1] = sigR2;

        numEntries = STATE_ENTRIES + NUM_MEAS_TYPE * numLandmarks;
        eye = new double[numEntries][numEntries];
        for (int i = 0; i < numEntries; i++) {
            eye[i][i] = 1.0;
        }

    }

    /* Node computation: */
    public boolean run() {
        System.out.println("Update.java: run() is called.");

        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, StandardCharsets.UTF_8, true))) {
            for (double value : input2) {
                // Only keep 4 decimal places
                writer.print(String.format("%.4f ", value));
            }
            writer.print("\n");
        } catch (IOException e) {
            e.printStackTrace();
        }

        numEntries = STATE_ENTRIES + NUM_MEAS_TYPE * numLandmarks;
        output1 = new double[numEntries];
        output2 = new double[numEntries * numEntries];

        X = input2;

        // Change input1 back to matrix P
        P = new double[numEntries][numEntries];
        for (int i = 0; i < numEntries; i++) {
            for (int j = 0; j < numEntries; j++) {
                P[i][j] = input1[i * numEntries + j];
            }
        }

        for (int l = 0; l < numLandmarks; l++) {
            double xT = X[0], yT = X[1], thetaT = X[2];
            double lX = X[STATE_ENTRIES + 2 * l];
            double lY = X[STATE_ENTRIES + 2 * l + 1];

            double q = (lX - xT) * (lX - xT) + (lY - yT) * (lY - yT);
            double qSqrt = Math.sqrt(q);

            double[][] H = new double[NUM_MEAS_TYPE][numEntries];
            H[0][0] = (lY - yT) / q;
            H[0][1] = (-lX + xT) / q;
            H[0][2] = -1.0;
            H[1][0] = (-lX + xT) / qSqrt;
            H[1][1] = (-lY + yT) / qSqrt;
            H[1][2] = 0.0;

            H[0][STATE_ENTRIES + 2 * l] = (-lY + yT) / q;
            H[0][STATE_ENTRIES + 2 * l + 1] = (lX - xT) / q;
            H[1][STATE_ENTRIES + 2 * l] = (lX - xT) / qSqrt;
            H[1][STATE_ENTRIES + 2 * l + 1] = (lY - yT) / qSqrt;

            double[][] HT = new double[numEntries][NUM_MEAS_TYPE];
            matrixTranspose(H, HT, NUM_MEAS_TYPE, numEntries);

            double expectedBeta = wrapToPi(Math.atan2(lY - yT, lX - xT) - thetaT);
            double expectedRange = qSqrt;

            double lBeta = input3[2 * l];
            double lRange = input3[2 * l + 1];

            double[][] diff = new double[NUM_MEAS_TYPE][1];
            diff[0][0] = lBeta - expectedBeta;
            diff[1][0] = lRange - expectedRange;

            double[][] temp1 = new double[NUM_MEAS_TYPE][numEntries];
            double[][] temp2 = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
            double[][] temp3 = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
            double[][] temp4 = new double[NUM_MEAS_TYPE][NUM_MEAS_TYPE];
            double[][] temp5 = new double[numEntries][NUM_MEAS_TYPE];
            double[][] kalmanGain = new double[numEntries][NUM_MEAS_TYPE];

            matrixMultiplication(H, P, temp1, NUM_MEAS_TYPE, numEntries, numEntries);
            matrixMultiplication(temp1, HT, temp2, NUM_MEAS_TYPE, numEntries, NUM_MEAS_TYPE);
            matrixAddition(temp2, measurementCov, temp3, NUM_MEAS_TYPE, NUM_MEAS_TYPE);
            matrix2dInverse(temp3, temp4);
            matrixMultiplication(P, HT, temp5, numEntries, numEntries, NUM_MEAS_TYPE);
            matrixMultiplication(temp5, temp4, kalmanGain, numEntries, NUM_MEAS_TYPE, NUM_MEAS_TYPE);

            // State update
            double[][] stateUpdate = new double[numEntries][1];
            matrixMultiplication(kalmanGain, diff, stateUpdate, numEntries, NUM_MEAS_TYPE, 1);

            for (int i = 0; i < numEntries; i++) {
                X[i] += stateUpdate[i][0];
            }

            // Covariance update
            double[][] covUpdate = new double[numEntries][numEntries];
            double[][] temp6 = new double[numEntries][numEntries];
            double[][] temp7 = new double[numEntries][numEntries];

            matrixMultiplication(kalmanGain, H, temp6, numEntries, NUM_MEAS_TYPE, numEntries);
            matrixSubtraction(eye, temp6, covUpdate, numEntries, numEntries);
            matrixMultiplication(covUpdate, P, temp7, numEntries, numEntries, numEntries);

            for (int i = 0; i < numEntries; i++) {
                for (int j = 0; j < numEntries; j++) {
                    P[i][j] = temp7[i][j];
                }
            }

        }


        for (int i = 0; i < numEntries; i++) {
            for (int j = 0; j < numEntries; j++) {
                output2[i * numEntries + j] = P[i][j];
            }
        }
        output1 = X;

        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, StandardCharsets.UTF_8, true))) {
            for (double value : output1) {
                // Only keep 4 decimal places
                writer.print(String.format("%.4f ", value));
            }
            writer.print("\n");
        } catch (IOException e) {
            e.printStackTrace();
        }

        return true;
    }

    /* Help methods: */
    public static void matrixTranspose(double[][] A, double[][] B, int row, int col) {
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                B[j][i] = A[i][j];
            }
        }
    }

    public static void matrixMultiplication(double[][] A, double[][] B, double[][] res, int rowA, int rowB, int colB) {
        for (int i = 0; i < rowA; i++) {
            for (int j = 0; j < colB; j++) {
                res[i][j] = 0;
                for (int k = 0; k < rowB; k++) {
                    res[i][j] += A[i][k] * B[k][j];
                }
            }
        }
    }

    public static void matrixAddition(double[][] A, double[][] B, double[][] res, int rows, int cols) {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[i][j] = A[i][j] + B[i][j];
            }
        }
    }

    public static boolean matrix2dInverse(double[][] A, double[][] inverse) {
        double det = A[0][0] * A[1][1] - A[1][0] * A[0][1];
        if (det == 0)
            return false;

        double invDet = 1.0 / det;
        inverse[0][0] = invDet * A[1][1];
        inverse[0][1] = -invDet * A[0][1];
        inverse[1][0] = -invDet * A[1][0];
        inverse[1][1] = invDet * A[0][0];
        return true;
    }

    public static void matrixSubtraction(double[][] A, double[][] B, double[][] res, int rows, int cols) {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[i][j] = A[i][j] - B[i][j];
            }
        }
    }

    public static double wrapToPi(double angle) {
        while (angle > Math.PI)
            angle -= 2 * Math.PI;
        while (angle < -Math.PI)
            angle += 2 * Math.PI;
        return angle;
    }

    /* Setters (for inputs): */
    public void set_input1(double[] i) {
        input1 = i;
    }

    public void set_input2(double[] i) {
        input2 = i;
    }

    public void set_input3(double[] i) {
        input3 = i;
    }

    /* Getters (for outputs): */
    public double[] get_output1() {
        return output1;
    }

    public double[] get_output2() {
        return output2;
    }
}