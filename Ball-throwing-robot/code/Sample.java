/*
 * Code generated by MIMOS tool.
 * Date: 2024/07/02 19:57:32
 * 
 * Generate the samples and calculate the rewards
 */

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
//import java.util.concurrent.ThreadLocalRandom;
import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Sample {
    // Debugging: Read the test samples from the file
    String filePath = "D:\\lxx\\thesis\\cases\\lxx\\Ball-throwing-robot\\data\\samples.txt";
    ArrayList<ArrayList<Double>> testSampleList = new ArrayList<>();
    static int sampleIndex = 0; // Max valure is 75,
                                // periods "Display"=2, the rest three periods=15, max simulation length is 163

    static int bootTime = 1;

    int numUpdates = 1; // Just used as an index for policy updates, not used in the computation
    int numSamples = 15;
    int topN = 5;
    final double goalPosition = -2;
    private static Random generator = new Random();

    ArrayList<Double> policyMu = new ArrayList<>();
    ArrayList<Double> policyCov = new ArrayList<>();
    ArrayList<Double> rewards = new ArrayList<>();
    ArrayList<ArrayList<Double>> parameters = new ArrayList<>();
    ArrayList<ArrayList<Double>> skillParams = new ArrayList<>();

    /* Inputs: */
    double[] input2; // Distribution (mean, variance), double[8]
    double[] input1; // Parameters of simulated samples, double[parameters * 75]
    double[] input3; // Positions of simulated samples, double[75]

    /* Outputs: */
    double[] output1; // Samples (skillParams), double[numSamples * parameters]
    int[] output2; // Indices of chosen samples, double[topN]
    double[] output3; // Policy (mean, variance), double[8]
    double[] output4; // Rewards, double[numSamples]

    /* Node computation: */
    public boolean run() {
        policyMu.clear();
        policyCov.clear();
        rewards.clear();
        parameters.clear();
        skillParams.clear();
        testSampleList.clear();

        // Debugging: Read the test samples from the file
        try (BufferedReader sampleFile = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = sampleFile.readLine()) != null) {
                String[] sampleTokens = line.split("\\s+");
                ArrayList<Double> testSample = new ArrayList<>();
                for (String token : sampleTokens) {
                    if (!token.isEmpty()) {
                        testSample.add(Double.parseDouble(token));
                    }
                }

                testSampleList.add(testSample);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Get information from the inputs
        // System.out.print("=====\ninput2: ");
        // for (double val : input2) {
        // System.out.print(val + " ");
        // }
        // System.out.println();

        // System.out.println("bootTime: " + bootTime);

        if (bootTime == 1) { // Initialize policy
            policyMu = new ArrayList<>(List.of(-5.0, -5.0, 0.0, 0.0));
            policyCov = new ArrayList<>(List.of(0.1, 0.1, 1.0, 1.0));
            // policyMu = new ArrayList<>(List.of(-0.5, -0.5, 0.0, 0.0));
            // policyCov = new ArrayList<>(List.of(0.1, 0.1, 0.5, 0.5));
            bootTime = 0;
        } else {
            for (int i = 0; i < 4; i++) {
                policyMu.add(input2[i]);
                policyCov.add(input2[i + 4]);
            }
        }

        ArrayList<Double> input1List = new ArrayList<Double>();
        for (double val : input1) {
            input1List.add(val);
        }

        for (int i = 0; i < input1List.size(); i += 4) {
            ArrayList<Double> params = new ArrayList<>(input1List.subList(i, Math.min(i + 4, input1List.size())));
            parameters.add(params);
        }

        System.out.println("Iteration : " + numUpdates);
        numUpdates++;

        System.out.println("Policy: " + policyMu);

        // Generate samples and calculate rewards
        for (int s = 0; s < numSamples; s++) {
            // ArrayList<Double> sampledParams = sample(policyMu, policyCov);
            // Use the samples from the paper
            ArrayList<Double> sampledParams = testSampleList.get(sampleIndex++);
            // sampleIndex++;

            // System.out.println("Sampled parameters: " + s + " : " + sampledParams);

            // Simulate real-world interaction
            double projectedPos = getPosition(sampledParams);
            // System.out.println("Projected position: " + projectedPos);

            double reward = 2.0 - Math.abs(projectedPos - goalPosition);
            // System.out.println(" Reward: " + reward);

            skillParams.add(sampledParams);
            rewards.add(reward);

            if (s == numSamples - 1) {
                System.out.println("Rewards: " + rewards);
            }

        }

        ArrayList<Double> sortedRewards = new ArrayList<>(rewards);
        Collections.sort(sortedRewards);
        // System.out.println("Sorted rewards: " + sortedRewards);

        double rewardThreshold = sortedRewards.get(numSamples - topN);
        ArrayList<Integer> chosenIndices = new ArrayList<>();
        for (int i = 0; i < numSamples; i++) {
            if (rewards.get(i) >= rewardThreshold) {
                chosenIndices.add(i);
                if (chosenIndices.size() == topN)
                    break;
            }
        }
        // System.out.println("Chosen indices: " + chosenIndices);

        output1 = new double[skillParams.size() * skillParams.get(0).size()];
        for (int i = 0; i < skillParams.size(); i++) {
            for (int j = 0; j < skillParams.get(0).size(); j++) {
                output1[i * skillParams.get(0).size() + j] = skillParams.get(i).get(j);
            }
        }

        output2 = new int[chosenIndices.size()];
        for (int i = 0; i < chosenIndices.size(); i++) {
            output2[i] = chosenIndices.get(i);
        }

        output3 = new double[8];
        for (int i = 0; i < 4; i++) {
            output3[i] = policyMu.get(i);
            output3[i + 4] = policyCov.get(i);
        }

        output4 = new double[rewards.size()];
        for (int i = 0; i < rewards.size(); i++) {
            output4[i] = rewards.get(i);
        }

        return true;
    }

    /* Setters (for inputs): */
    public void set_input2(double[] i) {
        input2 = i;
    }

    public void set_input1(double[] i) {
        input1 = i;
    }

    public void set_input3(double[] i) {
        input3 = i;
    }

    /* Getters (for outputs): */
    public double[] get_output1() {
        return output1;
    }

    public int[] get_output2() {
        return output2;
    }

    public double[] get_output3() {
        return output3;
    }

    public double[] get_output4() {
        return output4;
    }

    public static ArrayList<Double> sample(ArrayList<Double> mu, ArrayList<Double> cov) {
        ArrayList<Double> r = new ArrayList<>();
        for (int i = 0; i < mu.size(); i++) {
            double sample = mu.get(i) + cov.get(i) * generator.nextGaussian();
            r.add(sample);
        }
        return r;
    }

    // Returns the position of parameters (simulted data) that are closest to the
    // input parameters
    public double getPosition(ArrayList<Double> param) {
        int minIdx = 0;
        double minCost = getManhattanDistance(param, parameters.get(0));

        for (int i = 1; i < parameters.size(); i++) {
            double cost = getManhattanDistance(param, parameters.get(i));
            // System.out.println("Cost: " + cost);
            if (cost < minCost) {
                minIdx = i;
                minCost = cost;
            }
        }

        return input3[minIdx];
    }

    public static int getManhattanDistance(ArrayList<Double> v1, ArrayList<Double> v2) {
        int dist = 0;
        for (int i = 0; i < v1.size(); i++) {
            dist += Math.abs(v1.get(i) - v2.get(i));
        }

        return dist;
    }
}