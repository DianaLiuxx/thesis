/*
 * Code generated by MIMOS tool.
 * Date: 2024/05/05 13:41:17
 */

import java.util.Random;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.ArrayList;
import java.util.*;
import java.io.IOException;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.concurrent.ThreadLocalRandom;

public class CEM {
    private ArrayList<ArrayList<Double>> parameters = new ArrayList<>();
    private Random generator = new Random();

    String outfilePath = "D:\\lxx\\thesis\\cases\\lxx\\Ball-throwing-robot\\data\\outputs\\policy.txt";

    //int numUpdates = 5;
    int numUpdates = 1;
    int numSamples = 15;
    int topN = 5;

    final double goalPosition = -2;
    ArrayList<ArrayList<Double>> policiesLog = new ArrayList<>();

    // Initialize policy
    ArrayList<Double> policyMu = new ArrayList<>(List.of(-5.0, -5.0, 0.0, 0.0));
    ArrayList<Double> policyCov = new ArrayList<>(List.of(0.1, 0.1, 1.0, 1.0));

    /* Inputs: */
    double[] input2; // positions
    double[] input1; // parameters

    /* Outputs: */
    double[] output1; // Rewards

    /* Node computation: */
    public boolean run() {

        ArrayList<Double> input1List = new ArrayList<Double>();
        for (double val : input1) {
            input1List.add(val);
        }

        for (int i = 0; i < input1List.size(); i += 4) {
            ArrayList<Double> params = new ArrayList<>(input1List.subList(i, Math.min(i + 4, input1List.size())));
            parameters.add(params);
        }

        System.out.println("Iteration : " + numUpdates);
        numUpdates++;
        ArrayList<ArrayList<Double>> skillParams = new ArrayList<>();
        ArrayList<Double> rewards = new ArrayList<>();

        policiesLog.add(new ArrayList<>(policyMu));
        System.out.println("Policy: " + policyMu);


        for (int s = 0; s < numSamples; s++) {
            ArrayList<Double> sampledParams = sample(policyMu, policyCov);

            // Simulate real-world interaction
            double projectedPos = getPosition(sampledParams);
            double reward = 2.0 - Math.abs(projectedPos - goalPosition);
            System.out.println(" Reward: " + reward);

            skillParams.add(sampledParams);
            rewards.add(reward);
        }

        ArrayList<Double> sortedRewards = new ArrayList<>(rewards);
        Collections.sort(sortedRewards);

        double rewardThreshold = sortedRewards.get(numSamples - topN);
        ArrayList<Integer> chosenIndices = new ArrayList<>();
        for (int i = 0; i < numSamples; i++) {
            if (rewards.get(i) >= rewardThreshold) {
                chosenIndices.add(i);
                if (chosenIndices.size() == topN)
                    break;
            }
        }

        // Update policy
        for (int i = 0; i < policyMu.size(); i++) {
            double sum = policyMu.get(i);
            for (int idx : chosenIndices) {
                sum += skillParams.get(idx).get(i);
            }
            double mean = sum / (chosenIndices.size() + 1);

            double var = Math.pow(policyMu.get(i) - mean, 2);
            for (int idx : chosenIndices) {
                var += Math.pow(skillParams.get(idx).get(i) - mean, 2);
            }
            var /= (chosenIndices.size() + 1);

            policyMu.set(i, mean);
            policyCov.set(i, var);
        }
        
        output1 = new double[rewards.size()];
        for (int i = 0; i < rewards.size(); i++) {
            output1[i] = rewards.get(i);
        }

        // Write policy to file
        try (BufferedWriter outLogFile = new BufferedWriter(new FileWriter(outfilePath))) {
            for (ArrayList<Double> policy : policiesLog) {
                for (Double param : policy) {
                    outLogFile.write(param + " ");
                }
                outLogFile.newLine();
            }
        } catch (IOException e) {
            System.err.println("Error writing to log file: " + e.getMessage());
        }

        return true;
    }

    /* Setters (for inputs): */
    public void set_input2(double[] i) {
        input2 = i;
    }

    public void set_input1(double[] i) {
        input1 = i;
    }

    /* Getters (for outputs): */
    public double[] get_output1() {
        return output1;
    }

    public static ArrayList<Double> sample(ArrayList<Double> mu, ArrayList<Double> cov) {
        ArrayList<Double> r = new ArrayList<>();
        for (int i = 0; i < mu.size(); i++) {
            double mean = mu.get(i);
            double stddev = Math.sqrt(cov.get(i));
            double sample = ThreadLocalRandom.current().nextGaussian() * stddev + mean;
            r.add(sample);
        }

        return r;
    }

    public double getPosition(ArrayList<Double> param) {
        int minIdx = 0;
        double minCost = getManhattanDistance(param, parameters.get(0));

        for (int i = 1; i < parameters.size(); i++) {
            double cost = getManhattanDistance(param, parameters.get(i));
            if (cost < minCost) {
                minIdx = i;
                minCost = cost;
            }
        }

        return input2[minIdx];
    }

    private static double getManhattanDistance(ArrayList<Double> v1, ArrayList<Double> v2) {
        double dist = 0;
        for (int i = 0; i < v1.size(); i++) {
            dist += Math.abs(v1.get(i) - v2.get(i));
        }

        return dist;
    }
}