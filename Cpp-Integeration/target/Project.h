/*
 * Code generated by MIMOS tool.
 * Date: 2024/04/15 14:57:56
 */

#ifndef __MIMOS_PROJECT__
#define __MIMOS_PROJECT__

#include <iostream>
#include "SPSCQueue.h"
#include "SPSCRegister.h"
#include "schedulingInfo.h"
#include "PeriodicTask.h"
#include "Num_1.h"
#include "Num_2.h"
#include "Sum.h"


class Project {

    SPSCRegister<double> Num_1Suminput1;
    SPSCQueue<double, 128> Num_2Suminput2;

    Num_1 num_1;
    Num_2 num_2;
    Sum sum;

    bool isSumActivated() {
        return !Num_2Suminput2.isEmpty()&&!Num_1Suminput1.isEmpty();

    }

    void readTaskNum_1() {

    }
    void readTaskNum_2() {

    }
    void readTaskSum() {
        Num_2Suminput2.tryPop([&](double *msg) {
            sum.setInput2(*msg);
        });
        sum.setInput1(*Num_1Suminput1.pop());

    }

    bool taskNum_1() {
        readTaskNum_1();
        num_1.run();
        return true;

    }
    bool taskNum_2() {
        readTaskNum_2();
        num_2.run();
        return true;

    }
    bool taskSum() {
        if(isSumActivated()){
            readTaskSum();
            sum.run();
            return true;
        }
        return false;

    }

    void writeTaskNum_1() {

    }
    void writeTaskNum_2() {

    }
    void writeTaskSum() {

    }

    template <typename T>
    void sendData(SPSCQueue<T, 128> *fifo, T value) {
        T *msg;
        while((msg = fifo->alloc()) == nullptr);
        *msg = value;
        fifo->push();

    }
    template <typename T>
    void sendData(SPSCQueue<T, 128> *fifo, std::optional<T> value) {
        if(value.has_value()){
            sendData(fifo, value.value());
        }

    }
    template <typename T>
    void sendData(SPSCRegister<T> *reg, T value) {
        reg->push(value);

    }


public:

    void launch() {
        pthread_t mainThread = pthread_self();
        struct sched_param params;
        params.sched_priority = 80;
        if (int val = pthread_setschedparam(mainThread, SCHED_FIFO, &params) != 0) {
            std::cerr << val << " Error setting thread priority." << std::endl;
        }

        std::cout<<"starting the project..." <<std::endl;
        PeriodicTask ptNum_1 = PeriodicTask(20000000, NUM_1_OFFSET, NUM_1_CPU_ID, NUM_1_PRIORITY, NUM_1_POLICY);
        PeriodicTask ptNum_2 = PeriodicTask(2000000, NUM_2_OFFSET, NUM_2_CPU_ID, NUM_2_PRIORITY, NUM_2_POLICY);
        PeriodicTask ptSum = PeriodicTask(2000000, SUM_OFFSET, SUM_CPU_ID, SUM_PRIORITY, SUM_POLICY);
        struct timespec startApplicationTime;
        clock_gettime(CLOCK_MONOTONIC, &startApplicationTime);
        long long startUpTime = 100000000;
        ptNum_1.start(&startApplicationTime, startUpTime, [this](){
            return this->taskNum_1();
        }, [this]() {
            this->writeTaskNum_1();
        });

        ptNum_2.start(&startApplicationTime, startUpTime, [this](){
            return this->taskNum_2();
        }, [this]() {
            this->writeTaskNum_2();
        });

        ptSum.start(&startApplicationTime, startUpTime, [this](){
            return this->taskSum();
        }, [this]() {
            this->writeTaskSum();
        });
        std::chrono::system_clock::time_point timePt = std::chrono::system_clock::now() + std::chrono::seconds(40);
        std::this_thread::sleep_until(timePt);
        ptNum_1.stop();
        ptNum_2.stop();
        ptSum.stop();
    }

    Project() : Num_1Suminput1(0){}

};
#endif // __MIMOS_PROJECT__
