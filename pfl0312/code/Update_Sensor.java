/*
 * Code generated by MIMOS tool.
 * Date: 2024/03/13 20:12:58
 * 
 * Based on the laser data, update the particles' believe.
 */

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;

public class Update_Sensor {
    // private final static Logger logger =
    // LoggerFactory.getLogger(Update_Sensor.class);
    /* Inputs: */
    double[] input2; // Particles
    double[] input1; // Laser data

    /* Outputs: */
    double[] output1;
    static String outFilePath = "D:\\lxx\\thesis\\cases\\lxx\\pfl0312\\data\\outputs\\particles_sensor.txt";

    // These numbers are tuned for CMU's Wean Hall
    private int subsample = 1;
    private int zHit = 10;
    private double zShort = 0.01;
    private double zMax = 0.1;
    private int zRand = 10;
    private double sigmaHit = 50.0;
    private double lambdaShort = 0.1;

    private double minProbability = 0.35;
    private double maxRange = 1000.0;

    // The distance of the laser from the robot
    private double sensorOffset = 25.0;
    private static EnvMap occGrid;

    static String filePath = "D:\\lxx\\thesis\\cases\\lxx\\pfl0312\\data\\maps\\wean.dat";

    public Update_Sensor() {
        occGrid = new EnvMap(filePath);
    }

    /* Node computation: */
    public boolean run() {
        output1 = new double[input2.length];

        for (int i = 0; i < input2.length / 4; i++) {
            double x = input2[i * 4];
            double y = input2[i * 4 + 1];
            double theta = input2[i * 4 + 2];

            List<Double> zStar = new ArrayList<>();
            for (int d = 0; d < 180; d += subsample) {
                zStar.add(rayCast(x, y, theta, (double) (d)));
            }
            // // print zStar
            // for (int j = 0; j < zStar.size(); j++) {
            //     System.out.print("zStar: " + zStar.get(j)+ " ");
            // }
            // System.out.println("zstar done" + zStar.size());


            double probability = 1.0;
            for (int eIdx = 0; eIdx < zStar.size(); eIdx++) {
                int rIdx = eIdx * subsample;

                double expDist = zStar.get(eIdx);
                double readDist = input1[rIdx];
                probability *= calcProbability(readDist, expDist);
                //System.out.println("===============================Probability: " + probability);
            }
            output1[i * 4] = x;
            output1[i * 4 + 1] = y;
            output1[i * 4 + 2] = theta;
            output1[i * 4 + 3] = probability;
        }
        System.out.println("\nUpdate_Sensor: Sensor updated.\n");

        
        // Save the resampled particles to a txt file for visualization
        File file = new File(outFilePath);
        try (PrintWriter pw = new PrintWriter(file)) {
            for (double value : output1) {
                pw.println(value);
            }
            //System.out.println("Output for Resampled Particles is Completed!\n========================\n");
        } catch (Exception e) {
            e.printStackTrace();
        }

        return true;
    }

    /* Helper function */
    private double calcProbability(double zkt, double zktStar) {
        double pRand = 0;
        if (zkt >= 0 && zkt < maxRange) {
            pRand = 1.0 / maxRange;
        }

        double pMax = 0;
        if (zkt >= maxRange) {
            pMax = 1.0;
        }

        double pShort = 0;
        if (zkt >= 0 && zkt <= zktStar) {
            double n = 1.0 / (1 - Math.exp(-lambdaShort * zktStar));
            pShort = n * lambdaShort * Math.exp(-lambdaShort * zkt);
        }

        double pHit = 0;
        if (zkt >= 0 && zkt <= maxRange) {
            pHit = Math.exp(-0.5 * (zkt - zktStar) * (zkt - zktStar) / (sigmaHit * sigmaHit));
            pHit /= Math.sqrt(2 * Math.PI * sigmaHit * sigmaHit);
        }

        return zHit * pHit + zShort * pShort + zMax * pMax + zRand * pRand;
    }

    private double rayCast(double x, double y, double theta, double degree) {
        double xRay = x + sensorOffset * Math.cos(theta);
        double yRay = y + sensorOffset * Math.sin(theta);

        double step = occGrid.getResolution();
        double xStep = step * Math.cos(Math.PI / 2 + theta - degToRad(degree));
        double yStep = step * Math.sin(Math.PI / 2 + theta - degToRad(degree));

        double dist = 0;
        while (true) {
            dist += step;
            xRay += xStep;
            yRay += yStep;

            int xIdx = (int) (xRay / occGrid.getResolution());
            int yIdx = (int) (yRay / occGrid.getResolution());

            if (dist >= this.maxRange || xIdx >= occGrid.getX() || yIdx >= occGrid.getY() || xIdx < 0
                    || yIdx < 0) {
                break;
            }

            double occ = occGrid.getProb(xIdx, yIdx);
            if (occ == -1 || occ >= minProbability) {
                break;
            }
        }
        return dist;
    }

    private double degToRad(double angle) {
        return angle * (Math.PI / 180.0);
    }

    /* Setters (for inputs): */
    public void set_input2(double[] i) {
        input2 = i;
    }

    public void set_input1(double[] i) {
        input1 = i;
    }

    /* Getters (for outputs): */
    public double[] get_output1() {
        return output1;
    }

    /* Create a map class: EnvMap */
    private class EnvMap {
        private int sizeX;
        private int sizeY;
        private int resolution;
        private double[][] map;
        private List<Integer> freeXs = new ArrayList<>();
        private List<Integer> freeYs = new ArrayList<>();

        public EnvMap(String fileName) {
            try (BufferedReader mapFile = new BufferedReader(new FileReader(fileName))) {
                String strToken;
                int intToken;

                // Reading map size and resolution
                strToken = mapFile.readLine();
                intToken = Integer.parseInt(strToken.split(" ")[1]);
                this.sizeX = intToken;

                strToken = mapFile.readLine();
                intToken = Integer.parseInt(strToken.split(" ")[1]);
                this.sizeY = intToken;

                strToken = mapFile.readLine();
                intToken = Integer.parseInt(strToken.split(" ")[1]);
                this.resolution = intToken;

                this.sizeX /= resolution;
                this.sizeY /= resolution;

                this.map = new double[this.sizeX][this.sizeY];

                for (int i = 0; i < this.sizeX; i++) {
                    strToken = mapFile.readLine();
                    List<String> rowValues = Arrays.asList(strToken.split(" "));
                    for (int j = 0; j < this.sizeY; j++) {
                        double e = Double.parseDouble(rowValues.get(j));
                        this.map[i][j] = e;
                        if (e == 0) {
                            this.freeXs.add(i);
                            this.freeYs.add(j);
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        public int getX() {
            return this.sizeX;
        }

        public int getY() {
            return this.sizeY;
        }

        public double getResolution() {
            return this.resolution;
        }

        public boolean isValid(int x, int y) {
            return x >= 0 && x < this.sizeX && y >= 0 && y < this.sizeY;
        }

        public boolean isFree(int x, int y) {
            return this.map[x][y] == 0;
        }

        public double getProb(int x, int y) {
            return this.map[x][y];
        }

        // ? logger.info(mapString);
        public void printMap() {
            for (int i = 0; i < this.sizeX; i++) {
                for (int j = 0; j < this.sizeY; j++) {
                    System.out.printf("%.3f ", this.map[i][j]);
                }
                System.out.println();
            }
        }

        public double[][] getMap() {
            return this.map;
        }

        public List<Integer> getFreeXs() {
            return this.freeXs;
        }

        public List<Integer> getFreeYs() {
            return this.freeYs;
        }
    }
}
